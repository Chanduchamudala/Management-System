# analyzer.py
import time, json, argparse, os
from collections import defaultdict, deque
from scapy.all import sniff, IP, TCP, Raw
import yaml

ALERT_LOG = "alerts.log"
SUPPRESSION_SECONDS = 10

def load_rules(path="rules.yaml"):
    with open(path) as f:
        return yaml.safe_load(f) or {}

def now_ts():
    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())

class AlertManager:
    def __init__(self, logfile=ALERT_LOG):
        self.logfile = logfile
        open(self.logfile, "a").close()
        self.suppression = {}

    def _should_suppress(self, rule_id, src):
        key = (rule_id, src)
        last = self.suppression.get(key)
        if last and time.time() - last < SUPPRESSION_SECONDS:
            return True
        self.suppression[key] = time.time()
        return False

    def send(self, alert_obj):
        rule_id = alert_obj.get("rule_id")
        src = alert_obj.get("src", "?")
        if self._should_suppress(rule_id, src):
            return
        alert_obj.setdefault("time", now_ts())
        line = json.dumps(alert_obj)
        print("[ALERT]", line)
        with open(self.logfile, "a") as f:
            f.write(line + "\n")

class RuleEngine:
    def __init__(self, rules):
        self.sig_rules = rules.get("signatures", [])
        self.heu_rules = rules.get("heuristics", [])
        self.port_hist = defaultdict(lambda: deque())
        self.pkt_hist  = defaultdict(lambda: deque())

    def check_signatures(self, pkt):
        if (IP not in pkt) and (Raw not in pkt):
            return None
        src = pkt[IP].src if IP in pkt else None
        payload = bytes(pkt[Raw].load) if Raw in pkt else b""
        for r in self.sig_rules:
            field = r.get("field")
            if field == "src_ip" and src:
                if src in r.get("match", []):
                    return (r, {"matched": src})
            if field == "payload_contains" and payload:
                for p in r.get("match", []):
                    if p.encode() in payload:
                        return (r, {"matched": p})
        return None

    def check_heuristics(self, pkt):
        now = time.time(); alerts = []
        if IP not in pkt:
            return alerts
        src = pkt[IP].src
        self.pkt_hist[src].append(now)
        max_window = max((r.get("window_seconds", 60) for r in self.heu_rules), default=60)
        while self.pkt_hist[src] and self.pkt_hist[src][0] < now - max_window:
            self.pkt_hist[src].popleft()
        if TCP in pkt:
            if pkt[TCP].flags & 0x02:
                dport = pkt[TCP].dport
                self.port_hist[src].append((now, dport))
                while self.port_hist[src] and self.port_hist[src][0][0] < now - max_window:
                    self.port_hist[src].popleft()
        for r in self.heu_rules:
            mid = r.get("metric"); window = r.get("window_seconds",10); thr = r.get("threshold",100)
            if mid == "distinct_dst_ports":
                dq = self.port_hist[src]
                while dq and dq[0][0] < now - window:
                    dq.popleft()
                distinct = len({p for (_,p) in dq})
                if distinct >= thr:
                    alerts.append((r, {"distinct_ports": distinct})); dq.clear()
            elif mid == "pkt_rate":
                dq = self.pkt_hist[src]
                count = sum(1 for t in dq if t >= now - window)
                if count >= thr:
                    alerts.append((r, {"pkt_count": count})); dq.clear()
        return alerts

def make_alert(rule, src, details):
    return {
        "rule_id": rule.get("id"),
        "rule_name": rule.get("name"),
        "severity": rule.get("severity"),
        "src": src,
        "details": details,
        "time_epoch": int(time.time())
    }

def packet_handler(pkt, engine, am):
    try:
        sig = engine.check_signatures(pkt)
        if sig:
            rule, details = sig
            src = pkt[IP].src if IP in pkt else "?"
            am.send(make_alert(rule, src, details)); return
        heu = engine.check_heuristics(pkt)
        for rule, details in heu:
            src = pkt[IP].src if IP in pkt else "?"
            am.send(make_alert(rule, src, details))
    except Exception as e:
        print("handler error:", e)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--iface", help="Interface to sniff on (live).")
    parser.add_argument("--pcap", help="PCAP file to read (offline).")
    parser.add_argument("--rules", default="rules.yaml", help="Rules YAML path.")
    args = parser.parse_args()
    if not os.path.exists(args.rules):
        print("Rules file not found:", args.rules); return
    rules = load_rules(args.rules)
    engine = RuleEngine(rules); am = AlertManager()
    if args.pcap:
        print("Reading pcap:", args.pcap)
        sniff(offline=args.pcap, prn=lambda p: packet_handler(p, engine, am), store=False)
    else:
        if not args.iface:
            print("Provide --iface or --pcap. Example: sudo python analyzer.py --iface eth0"); return
        print("Sniffing on", args.iface)
        sniff(iface=args.iface, prn=lambda p: packet_handler(p, engine, am), store=False)

if __name__ == "__main__":
    main()
